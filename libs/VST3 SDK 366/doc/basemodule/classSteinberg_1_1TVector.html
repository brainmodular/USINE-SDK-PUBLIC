<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Base Module: TVector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxysmtg.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Base Module
   &#160;<span id="projectnumber">VST 3.6.6</span>
   </div>
   <div id="projectbrief">SDK for developing VST Plug-in</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSteinberg.html">Steinberg</a></li><li class="navelem"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">TVector&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__baseContainer.html">Template Containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is a base class that i...">TVector</a> provides a basic templated container for arrays of dynamic size<a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is a base class that i...">TVector</a> is a base class that is not meant to be derived from.  
 <a href="classSteinberg_1_1TVector.html#details">More...</a></p>

<p><code>#include &lt;tvector.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a35173dc44fc5e7ed6ff99b776761b7f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a35173dc44fc5e7ed6ff99b776761b7f9">TVector</a> (int32 <a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a>=0, const T *items=0)</td></tr>
<tr class="memdesc:a35173dc44fc5e7ed6ff99b776761b7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor specifying the properties of the <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is a base class that i...">TVector</a>.  <a href="#a35173dc44fc5e7ed6ff99b776761b7f9">More...</a><br /></td></tr>
<tr class="separator:a35173dc44fc5e7ed6ff99b776761b7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752856f0b37a2fae6823420dd1058d26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a752856f0b37a2fae6823420dd1058d26">TVector</a> (int32 <a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a>, const T &amp;item)</td></tr>
<tr class="memdesc:a752856f0b37a2fae6823420dd1058d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor fills a given number of elements in the vector with copies of a given item.  <a href="#a752856f0b37a2fae6823420dd1058d26">More...</a><br /></td></tr>
<tr class="separator:a752856f0b37a2fae6823420dd1058d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51518b8ca9836a9622d1267c1793a4c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a51518b8ca9836a9622d1267c1793a4c4">TVector</a> (const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;otherVector)</td></tr>
<tr class="memdesc:a51518b8ca9836a9622d1267c1793a4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor.  <a href="#a51518b8ca9836a9622d1267c1793a4c4">More...</a><br /></td></tr>
<tr class="separator:a51518b8ca9836a9622d1267c1793a4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6db7027e899293a01b21bf15340cbc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a4f6db7027e899293a01b21bf15340cbc">~TVector</a> ()</td></tr>
<tr class="separator:a4f6db7027e899293a01b21bf15340cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a84a83b35447e32ab4cd1378bc8e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#ac5a84a83b35447e32ab4cd1378bc8e73">operator=</a> (const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;otherVector)</td></tr>
<tr class="memdesc:ac5a84a83b35447e32ab4cd1378bc8e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Destructor. Releases all memory allocated by the vector. The destructor is note declared virtual and thus derivation from <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is a base class that i...">TVector</a> is not recommended.  <a href="#ac5a84a83b35447e32ab4cd1378bc8e73">More...</a><br /></td></tr>
<tr class="separator:ac5a84a83b35447e32ab4cd1378bc8e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cff042faf3fc4f6b976d4ebb7ecf3d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a2cff042faf3fc4f6b976d4ebb7ecf3d8">operator+=</a> (const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;otherVector)</td></tr>
<tr class="memdesc:a2cff042faf3fc4f6b976d4ebb7ecf3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append another vector to this vector.  <a href="#a2cff042faf3fc4f6b976d4ebb7ecf3d8">More...</a><br /></td></tr>
<tr class="separator:a2cff042faf3fc4f6b976d4ebb7ecf3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4501211c2e66ae89aebed443df62e530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a4501211c2e66ae89aebed443df62e530">operator+</a> (const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;otherVector) const </td></tr>
<tr class="memdesc:a4501211c2e66ae89aebed443df62e530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new vector that appends the contents of another vector to this vector.  <a href="#a4501211c2e66ae89aebed443df62e530">More...</a><br /></td></tr>
<tr class="separator:a4501211c2e66ae89aebed443df62e530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd19c533c2123be58afcdd1c3caa6a5"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#adfd19c533c2123be58afcdd1c3caa6a5">operator[]</a> (int32 idx)</td></tr>
<tr class="memdesc:adfd19c533c2123be58afcdd1c3caa6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator.  <a href="#adfd19c533c2123be58afcdd1c3caa6a5">More...</a><br /></td></tr>
<tr class="separator:adfd19c533c2123be58afcdd1c3caa6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76480513eeaa66e4466f2003049e6ca"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#ae76480513eeaa66e4466f2003049e6ca">at</a> (int32 idx)</td></tr>
<tr class="separator:ae76480513eeaa66e4466f2003049e6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808d0a6e9bc2c9140d55f6682e845f65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a808d0a6e9bc2c9140d55f6682e845f65">operator()</a> (int32 idx, int32 <a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a>) const </td></tr>
<tr class="memdesc:a808d0a6e9bc2c9140d55f6682e845f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function operator.  <a href="#a808d0a6e9bc2c9140d55f6682e845f65">More...</a><br /></td></tr>
<tr class="separator:a808d0a6e9bc2c9140d55f6682e845f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0de3f5d4514b90b8e820a65bc8aaa0c"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a> () const </td></tr>
<tr class="separator:ae0de3f5d4514b90b8e820a65bc8aaa0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b26969d605e04890755d3cc3ef58b8"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a52b26969d605e04890755d3cc3ef58b8">array</a> () const </td></tr>
<tr class="memdesc:a52b26969d605e04890755d3cc3ef58b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Returns the size of this vector  <a href="#a52b26969d605e04890755d3cc3ef58b8">More...</a><br /></td></tr>
<tr class="separator:a52b26969d605e04890755d3cc3ef58b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf179c9a4ea046cc4d5388ea85df1bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#acbf179c9a4ea046cc4d5388ea85df1bb">assign</a> (const T *items, int32 <a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a>=1)</td></tr>
<tr class="memdesc:acbf179c9a4ea046cc4d5388ea85df1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Returns a const pointer to the first element stored in this vector. The pointer should not be stored as it will change on insertion and deletion of new elements.  <a href="#acbf179c9a4ea046cc4d5388ea85df1bb">More...</a><br /></td></tr>
<tr class="separator:acbf179c9a4ea046cc4d5388ea85df1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5476017916a6d386748525fc8b3926d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#ad5476017916a6d386748525fc8b3926d">assign</a> (const T &amp;item, int32 <a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a>=1)</td></tr>
<tr class="memdesc:ad5476017916a6d386748525fc8b3926d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign function that replaces this vector with an arbitrary number of copies of a given element.  <a href="#ad5476017916a6d386748525fc8b3926d">More...</a><br /></td></tr>
<tr class="separator:ad5476017916a6d386748525fc8b3926d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819e1c510a77bc600f5bef47267044cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a819e1c510a77bc600f5bef47267044cd">append</a> (const T *items, int32 <a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a>=1)</td></tr>
<tr class="memdesc:a819e1c510a77bc600f5bef47267044cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append function that appends elements stored at the given pointer location to this vector.  <a href="#a819e1c510a77bc600f5bef47267044cd">More...</a><br /></td></tr>
<tr class="separator:a819e1c510a77bc600f5bef47267044cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb9da98f38251cb7ab29ab10b5211c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a4fb9da98f38251cb7ab29ab10b5211c8">append</a> (const T &amp;item, int32 <a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a>=1)</td></tr>
<tr class="memdesc:a4fb9da98f38251cb7ab29ab10b5211c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append function that appends an arbitrary number of copies of a given element to this vector.  <a href="#a4fb9da98f38251cb7ab29ab10b5211c8">More...</a><br /></td></tr>
<tr class="separator:a4fb9da98f38251cb7ab29ab10b5211c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62766d8cdcfd89dc87172417a1a4ff16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a62766d8cdcfd89dc87172417a1a4ff16">insert</a> (int32 idx, const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;otherVector)</td></tr>
<tr class="memdesc:a62766d8cdcfd89dc87172417a1a4ff16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert function that inserts another vector at a given position of this vector.  <a href="#a62766d8cdcfd89dc87172417a1a4ff16">More...</a><br /></td></tr>
<tr class="separator:a62766d8cdcfd89dc87172417a1a4ff16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536eaddb43ec60f1864ad70295167c7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a536eaddb43ec60f1864ad70295167c7b">insert</a> (int32 idx, const T *items, int32 <a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a>=1)</td></tr>
<tr class="memdesc:a536eaddb43ec60f1864ad70295167c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert function that inserts elements stored at the given pointer location at a given position into this vector.  <a href="#a536eaddb43ec60f1864ad70295167c7b">More...</a><br /></td></tr>
<tr class="separator:a536eaddb43ec60f1864ad70295167c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea82533c42b39f328c3a1b510f450907"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#aea82533c42b39f328c3a1b510f450907">insert</a> (int32 idx, const T &amp;item, int32 <a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a>=1)</td></tr>
<tr class="memdesc:aea82533c42b39f328c3a1b510f450907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert function that inserts an arbitrary number of copies of a given element into a given position in this vector.  <a href="#aea82533c42b39f328c3a1b510f450907">More...</a><br /></td></tr>
<tr class="separator:aea82533c42b39f328c3a1b510f450907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be8c4a7ceb074fef433e28d2152a89a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a9be8c4a7ceb074fef433e28d2152a89a">remove</a> (int32 idx, int32 <a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a>=1)</td></tr>
<tr class="memdesc:a9be8c4a7ceb074fef433e28d2152a89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes items from the vector.  <a href="#a9be8c4a7ceb074fef433e28d2152a89a">More...</a><br /></td></tr>
<tr class="separator:a9be8c4a7ceb074fef433e28d2152a89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3399311490663d6a010689508f2cae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a5a3399311490663d6a010689508f2cae">subVector</a> (int32 idx, int32 <a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a>) const </td></tr>
<tr class="memdesc:a5a3399311490663d6a010689508f2cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to extract a subset of the vector.  <a href="#a5a3399311490663d6a010689508f2cae">More...</a><br /></td></tr>
<tr class="separator:a5a3399311490663d6a010689508f2cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722aff9bec64ecb2cfd7ed005fa97b62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a722aff9bec64ecb2cfd7ed005fa97b62">resize</a> (int32 <a class="el" href="classSteinberg_1_1TVector.html#ae0de3f5d4514b90b8e820a65bc8aaa0c">size</a>)</td></tr>
<tr class="memdesc:a722aff9bec64ecb2cfd7ed005fa97b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Clears the vector and sets the size to 0  <a href="#a722aff9bec64ecb2cfd7ed005fa97b62">More...</a><br /></td></tr>
<tr class="separator:a722aff9bec64ecb2cfd7ed005fa97b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1678ed50ddaed55228e790c7cd534f88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSteinberg_1_1TVector.html#a1678ed50ddaed55228e790c7cd534f88">grow</a> (int32 minSize, int32 delta=-1)</td></tr>
<tr class="separator:a1678ed50ddaed55228e790c7cd534f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class Steinberg::TVector&lt; T &gt;</h3>

<p><a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is a base class that i...">TVector</a> provides a basic templated container for arrays of dynamic size</p>
<p><a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is a base class that i...">TVector</a> is a base class that is not meant to be derived from. </p>
<p>Elements can be stored and removed from the vector, always causing a resize to the appropriate new size.</p>
<p>Thus, the container always keeps a memory efficient perfect fit. <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is a base class that i...">TVector</a> is not suited for high performance insert and removal operations. Consider to use a class with a more sophisticated allocation algorithm if the size of your container is bound to change often.</p>
<p>Insertions and removals on <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is a base class that i...">TVector</a> are neither suited for real time processing and are not thread safe because reallocation of memory is neccesary. Random access to elements of the vector is lock free and thread safe.</p>
<p>Because of the TVectors policy to always reallocate new memory, it is not recommended to store pointers or references to the contents of the vector outside of <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is a base class that i...">TVector</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a35173dc44fc5e7ed6ff99b776761b7f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>items</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor specifying the properties of the <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is a base class that i...">TVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of items to be inserted on construction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">items</td><td>pointer to the memory were the items are stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a752856f0b37a2fae6823420dd1058d26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor fills a given number of elements in the vector with copies of a given item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of copies of the given item to be inserted on construction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>reference to the item that is to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51518b8ca9836a9622d1267c1793a4c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherVector</td><td>the vector that is to be copied on construction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f6db7027e899293a01b21bf15340cbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classSteinberg_1_1TVector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac5a84a83b35447e32ab4cd1378bc8e73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt; Destructor. Releases all memory allocated by the vector. The destructor is note declared virtual and thus derivation from <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is a base class that i...">TVector</a> is not recommended. </p>
<p>Assignment operator. <a class="el" href="classSteinberg_1_1TVector.html" title="TVector provides a basic templated container for arrays of dynamic sizeTVector is a base class that i...">TVector</a> always reallocated new memory on assignment. Even when both vectors have the same size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherVector</td><td>the vector that is to be copied on assignment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2cff042faf3fc4f6b976d4ebb7ecf3d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append another vector to this vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherVector</td><td>The vector that should be appended to this vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4501211c2e66ae89aebed443df62e530"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherVector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new vector that appends the contents of another vector to this vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherVector</td><td>The vector that should be appended to this vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfd19c533c2123be58afcdd1c3caa6a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access operator. </p>
<p>Used for read and write access. Note that their is no const counterpart. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The index of the element to be accessed. If idx &lt; 0, idx is set to 0. If idx &gt;= (size of this vector), the vector is resized to idx to make access possible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae76480513eeaa66e4466f2003049e6ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; at </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a808d0a6e9bc2c9140d55f6682e845f65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; operator() </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function operator. </p>
<p>Used to extract a subset of the vector. The returned vector is a new vector that contains copies of the elements in the requested subset. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The index of the first element of the subvector. If idx &lt; 0 or idx &gt;= (size of this vector), an empty vector is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements to be contained in the new vector. If idx + size &gt; (size of this vector), an empty vector is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0de3f5d4514b90b8e820a65bc8aaa0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32 size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a52b26969d605e04890755d3cc3ef58b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt; Returns the size of this vector </p>

</div>
</div>
<a class="anchor" id="acbf179c9a4ea046cc4d5388ea85df1bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; assign </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt; Returns a const pointer to the first element stored in this vector. The pointer should not be stored as it will change on insertion and deletion of new elements. </p>
<p>Assign function that replaces this vector with the elements stored at the given pointer location. Always allocates new memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">items</td><td>pointer to the memory were the items are stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of items to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad5476017916a6d386748525fc8b3926d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; assign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign function that replaces this vector with an arbitrary number of copies of a given element. </p>
<p>Always allocates new memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>reference to the item that is to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of copies of the given item to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a819e1c510a77bc600f5bef47267044cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; append </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append function that appends elements stored at the given pointer location to this vector. </p>
<p>Always allocates new memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">items</td><td>pointer to the memory were the items are stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of items to be appended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4fb9da98f38251cb7ab29ab10b5211c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append function that appends an arbitrary number of copies of a given element to this vector. </p>
<p>Always allocates new memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>reference to the item that is to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of copies of the given item to bo appended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62766d8cdcfd89dc87172417a1a4ff16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; insert </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert function that inserts another vector at a given position of this vector. </p>
<p>Always allocates new memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>index at wich to insert the new vector. If idx = 0, the other vector will be prepended to this vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherVector</td><td>const reference to the other vector that is to be inserted into this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a536eaddb43ec60f1864ad70295167c7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; insert </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert function that inserts elements stored at the given pointer location at a given position into this vector. </p>
<p>Always allocates new memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>index at wich to insert the new items. If idx = 0, the other items will be prepended to this vector. If idx &lt; 0 or index &gt; (size of this vector), nothing will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">items</td><td>pointer to the memory were the items are stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of items to be inserted . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea82533c42b39f328c3a1b510f450907"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; insert </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert function that inserts an arbitrary number of copies of a given element into a given position in this vector. </p>
<p>Always allocates new memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>index at wich to insert the new items. If idx = 0, the other items will be prepended to this vector. If idx &lt; 0 or index &gt; (size of this vector), nothing will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>reference to the item that is to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of copies of the given item to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9be8c4a7ceb074fef433e28d2152a89a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; &amp; remove </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes items from the vector. </p>
<p>Always allocates new memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The index of the first element to be removed from the vector. If idx &lt; 0 idx &gt;= (size of this vector), the vector is returned unchanged. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements to be removed from the vector. If idx + size &gt;= (size of this vector), the vector is returned unchanged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a3399311490663d6a010689508f2cae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSteinberg_1_1TVector.html">TVector</a>&lt; T &gt; subVector </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to extract a subset of the vector. </p>
<p>The returned vector is a new vector that contains copies of the elements in the requested subset. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The index of the first element of the subvector. If idx &lt; 0 or idx &gt; (size of this vector), an empty vector is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements to be contained in the new vector. If idx + size &gt; (size of this vector), an empty vector is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8bb3912a3ce86b15842e79d0b421204"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a722aff9bec64ecb2cfd7ed005fa97b62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool resize </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt; Clears the vector and sets the size to 0 </p>
<p>Resize the whole vector and copies the contained elements to a new location. Always allocates new memory. Even if size == (size of this vector) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the vector after resize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1678ed50ddaed55228e790c7cd534f88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool grow </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>minSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>delta</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<html>
<head>
	<title>Empty</title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<meta name="Author" content="mario">
</head>
<body>
<br/>
<hr width="100%" size="2" align="left" />
<div align=left>
Copyright &copy;2016 <a href="http://www.steinberg.net" target="_blank"><u>Steinberg Media Technologies GmbH</u></a>.
All Rights Reserved.
</div>
</body>
</html>
